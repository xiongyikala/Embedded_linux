
跟我一起写 Makefile

编译的原理：
UNIX 下是 .o 文件，即 Object File，这个动作叫做编译（compile）.
然后再把大量的 Object File 合成执行文件，这个动作叫作链接（link）。
编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，
通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声
明，而定义应该放在 C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标
文件。一般来说，每个源文件都应该对应于一个中间目标文件（O 文件或是 OBJ 文件）。链
接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O 文件或是 OBJ
文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件
（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链
接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件
打个包，在 Windows 下这种包叫“库文件”（Library File)，也就是 .lib 文件，在 UNIX
下，是 Archive File，也就是 .a 文件。
总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译
时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出
一个警告，但可以生成 Object File。而在链接程序时，链接器会在所有的 Object File 中
找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在 VC 下，这种错
误一般是：Link 2001 错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的
Object File. 


编译的规则是： 
1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
2）如果这个工程的某几个C文件或C文件对应的头文件被修改了，
那么我们就需要编译被修改的C文件，并链接目标程序。

格式：
target ... : prerequisites ...
	command
	
	
make的工作原理：

寻找makefile文件---寻找第一个目标文件-|-找到--把这个文件作为最终的目标文件
                                      |-没找到---寻找依赖---编译
                                      
如果这个工程已被编译过了，当我们修改了其中一个源文件，比如
file.c，那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系
后面所定义的命令），于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比
edit 要新，所以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。
而如果我们改变了“command.h”，那么，kdb.o、command.o 和 files.o 都会被重编译，
并且，edit 会被重链接。

文件修改重编译后就会比目标文件新，那么目标文件就会被重编译或重链接----时间戳原理

引用变量要加括号给钱


Makefile 里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。