c++:
	红帽linux系统eclipse下开发(编译工具（gcc）->运行环境（jdk）集成开发工具->（eclipse）)
			1.eclipse（jdk）环境搭建
				确定系统有gcc
				安装jdk（权限chmod）
				环境的配置：主要是jdk的bin文件夹下的工具
						vim /etc/profile(注意可写权限)
						在最下行输入export JAVA_HOME=/root/jdk
			            			export PATH=$JAVA_PATH/bin:$PATH
			            			export CLASSPATH=.
						环境的起效要重新启动
							检测是否成功 输入Java会出现超过4行环境成功
												 输入Javac会出现超过4行环境成功
			
			2.eclipse
				在project explorer框中右键菜单下建立工程
				程序写完按锤子的图标是进行编译，播放键运行
				
	
		从c到c++
				对c的增强：1.在c语言面向过程的扩充。2.加入了面向对象的机制。
				
				c++的输入输出：cin，count（#include <iostream> using namespace std;（释：指名命名空间））
						（换行endl是"\n"的宏）
						cin>>data;
						cout<<"data\n"<<data<<endl;
						编译g++ 文件 -o 别名
				
				字符串变量Stirng	
						字符串连接用加号，字符串变量的比较直接用关系运算符==，>等
					
				引用：对c的扩充，新的变量类型，对一个变量起一个别名。
						int a = 20;
						int &b = a；//创建引用类型时。要立刻“赋值”。一经引用，该引用变量名不可再引用（不完全的经验判定：&等于号之前是引用，等于号之后是取地址）
						注意：  （1）引用是变量的别名，不会再开辟空间。
										（2）引用在实际开发中，只使用于函数的形式参数。
										（3）比喻：引用是一种受限指针。
										（4）引用能做的事指针都能做，而指针能做的事引用不一定能用。
										（5）引用的底层实现多数编译器也是指针。
						
				面向对象
						域名访问符::方法如果只在student类中定义了成员函数void study();
						 						在类外面实现 void student：：study(){
						 											cout<<"study"<<endl;
						 						}
						 						
						 c++创建的对象是普通的变量，Java里是分配在堆中。
						 c++创建的对象中的普通变量在栈中，成员函数在代码段供各个对象共用。
						 
						 成员函数重载：函数名相同，参数类型或个数不同。
						 函数默认参数：多个默认参数前一个定义了，之后的参数值都要定义。
						 
						 构造函数：对象创建时会调用构造函数进行初始化赋值。
						 
						 析构函数：构造函数前加~，用法和构造函数相反。对象销毁时调用。
						 
						 关键字this是指针
								--构造函数中的this指向当前正在创建的对象
								--成员函数中的this指向当前正在调用该函数的对象

				重点：可以实现同一个类中函数与函数之间相互调用
							成员函数可以通过this访问成员变量
							--成员函数不能通过this访问构造函数
				
				
				指向对象的指针 Stu *p

				指向成员函数的指针
						1.取地址
						2.定义指针接收
						3.调用
				int Stu::show1(int x, int y) {
						cout<<"show1"<<endl;
						return 0;
				int Stu::show2(int x, int y) {
					cout<<"show2"<<endl;
					return 0;
				}
			void Stu::show3() {
					cout<<"show3()"<<endl;
			}

			int(Stu::*p)(int,int) == &Stu::show
		
			先要有对象
			(Stu.*p)(1,2);

			//	int Stu::show1(int x, int y)
			//成员函数返回类型  (类名∷*指针变量名)(参数列表)=&类名∷成员函数名;
			int(Stu::*p)(int, int) = &Stu::show1; //p--->Stu::show1

			//(对象.*指针变量名)(实参);
			Stu stu;
			(stu.*p)(1,2);//show1
	
	
			p=&Stu::show2;//p--->show2;  show1的参数形式与show2相同
			(stu.*p)(1,2);//show2

			void(Stu::*p3)()=&Stu::show3;
			(stu.*p3)();//show3
	
	
	
			常成员变量：只能通过构造函数的初始化表初始化
			而普通变量可以使用this
		

			常成员函数：不能修改对象
			1.不能修改成员变量的值
			2.只能调用成员函数
			3.普通成员函数可以调用成员函数
				const写在定义后面


			常对象：不能修改对象
			1.不能修改成员变量的值
			2.只能调用成员函数
			3.必须在定义常对象类的时候就用
			构造函数把所有的成员变量初始化（常+普通）

	
			动态创建对象--堆
			new--delete
			malloc--不会调用构造函数

			对象的赋值与复制(克隆)
			赋值：
			创建---赋值
			Stu stu1(1, 2);
			Stu stu2(3,4);
			stu2 = stu1;
			stu2.show();


			复制(克隆)：
			创建时克隆
			---传参，返回
			//对象复制
			void f3(Stu  stu) {
			//	cout<<&stu<<endl;
			stu.show();//age=1,no=2
			}

			Stu f4() {
			Stu stux(1, 2);
			return stux;
			}

			int main() {
			Stu stu1(1,2);
			//	f3(stu1);
			//	cout<<&stu1<<endl;

			Stu stu2 =  f4();//对象复制 stu2: age=1, no=2

			Stu stu3;
			stu3 = f4();//对象赋值stu3  age=1, no=2

			return 0;
			}


内存溢出难点：		复制构造函数：(引用类型作为参数，不写。系统默认添加)
			  			形式：Stu::Stu(Stu &r){
			  					this->age = r.age;
			  					this->no = r.no;
			  			}	
			  
			
			静态成员变量：Static int i = 1;
						写在函数体中，系统由于已经创建了跳过执行
					  静态成员变量在创建时对象前就已经创建了，供所用对象共用。对象的大小不包括静态成员大小，静态成员在数据代码段分配。
						必须在类体外初始化，建议放在main函数中。开发时静态成员变量过多时，可以定义一个头文件（防止重复导入）
				访问方式：1.和普通变量一样
									2.类名：：i
									
			静态成员函数：
							没有this
							
							
			访问权限修饰符：
					public ：公有。任何位置可被访问。
					protect：受保护。当前类和派生类可访问。
					private:私有的。当前类访问
			
				使用：修饰成员，构造函数，析构函数，改变成员的作用域。
							（只改变作用域，不改变内存分配）
			
			
			友元：打破访问权限的限制，访问权限不生效。
			
					

继承与派生	（意思一样，指代的对象相反）
			继承：（解决代码的重用）一个派生类有两个和多个基类称为多重继承。
			派生：
						class B:public A(A公有继承A，不写表示私有继承，多继中间用逗号隔开。)
									{
											........
									}
									
					
			使用访问权限限制继承
				1.基类中private修饰的成员始终不能被派生类继承
				2.基类中public修饰的成员与protected修饰的成员
				始终可以被派生类继承

			private属性不可继承
			--继承后相当于在派生类中声明了继承的成员
			--注意访问权限的传递规则
			public继承---原样继承
			protected继承---protected
			private继承---private
				
			派生类对象被创建时，基类对象会被先创建
			派生类对象释放时，先执行派生类析构函数，再执行基类的析构函数。
			
			派生类的构造函数和析构函数：
			派生类的构造函数调用基类构造函数
			1.写--使用初始化成员表
			B::B():A(23),x(123){//B类中有一个成员为x

			}
			B::B(int y):A(y),x(123){

			}
			2.默认不写时，调用不用传参的构造函数
			B::B(int y):A(),x(123){

			}
			<======>
			B::B(int y),x(123){

			}
			
			多基继承的二义性：
					class A1{int a；void m（）；}
					class A2{int a；void m（）；}
					class C：public A1，public A2;
							
			共同基类产生的二义性：
					class ： public A{int a；void m（）；}
					class ： public A{int a；void m（）；}
					class C：public A1，public A2;
					
			虚基继承；
					class ：virtual public A{int a；void m（）；}
					class ：virtual public A{int a；void m（）；}
					class C：public A1，public A2;
					
			

			--多基继承可能会产生二异性
			b.A1::a = 2;
			b.A1::m();
			b.A2::a = 2;
			b.A2::m();

			共同基类产生的二异性（多级继承+多个基类）
			解决方法：虚基继承，虚基派生---只继承一份相同的A成员
			class B1:virtual public A{..}
			class B2:virtual public A{..}
			class A: public B1,B2{..}
			多级继承（传递性）

			赋值：同类，派生类-->基类
			派生类对象向基类对象赋值
			
			赋值：同类，派生类-->基类
			派生类对象向基类对象赋值

			基类声明的指针变量和引用变量
			指向派生类的对象
			派生类对象与它包含的“基类对象”首地址相同
			指针访问的对象与指针的类型相关

			组合：对象作为成员变量
			初始化成员表--指定组合的成员函数
			---类似java里的接口，添加功能
			按java的思想是实现接口，接口是实现的父类

			--便于扩展，便于维护
			--符合面向对象思想

			内存的处理上
			java的内存的处理不用用户来管理，内存自动回收

			C++和C一样内存的操作是最难的部分，容易出现内存泄漏

			java可以跨平台
			C++在Qt平台也可以跨平台

			设计原则--设计模式：23种


			基类+组合
			基类的构造函数最先执行

			管理资源--电脑，人等

			思考：
			单基继承---类型继承
			继承与组合--类型上的包含关系，同类继承
			组合--整体与部分的关系，此部分不是整体必须的
			只是功能的扩展


			多态：--使用回调实现的


			隐藏：派生类与基类成员名相同时，
			派生类成员就会隐藏基类成员
			函数原型相同--特殊的隐藏：重写


			override(重写)
			overload（重载）


			虚函数：
			对象指针访问普通函数时，只看指针函数的类型-base
			对象指针访问虚函数时，只看指针的值--child

			---可以实现回调
			---后写的代码A指向会触发先写的代码
			调用后写的代码B

			后写的代码：
					1.触发代码
					2.回调函数代码

			开线程：
					1.触发代码：phread_create(,函数指针)
					2.回调代码：线程执行函数
			
			多态：指针访问虚函数
			重载，重写，this

			动态关联，动态编联，
			静态关联

			虚析构函数：解决内存泄漏
			--基类指针指向动态创建的派生类对象
			virtual ~A();
			基类的虚析构函数会传递给派生类

			核心：
			1.类 对象
			2.继承
			3.组合
			4.虚函数
			5.抽象类


			纯虚函数--抽象方法
			virtual 函数类型 函数名（参数列表） = 0；
			抽象类：包含纯虚函数的类
			可以用抽象类创建的指针和引用
			类指向抽象类的派生类对象

			抽象类的派生类没有把抽象类的纯虚函数
			实现完，那么这个类也是抽象类
			纯虚函数被派生类实现以后即为虚函数



			重写：为了解决代码的重用
			实际开发中，都是重写虚函数
			使用虚函数就是有重写的需求

			重写是对继承下来的函数体不满意

			
			构造函数访问权限修饰符
			public
			protected
			private
			
			
			名称空间
			
			
			
			
			泛型/模板（同一概念，不同称呼）
			用于c语言函数中，成员函数中
			函数模板： template<class T1>
									模板函数（返回值，参数，函数体）
			考虑两个因素：编译的格式是否匹配，函数体操作是否合法。
			摸板函数声明定义都写在.h文件中，不用定义在.cpp文件中。
			
			
			STL容器
			数据存储对象类型，持有其它对象或其它对象的指针。
			顺序性容器：vecter，deque，list
				vecter每次后插入一个元素会将原先的数组拷贝一份再在后面
				添加新元素，之后删除原先的数组。效率低，数据短的还好。查询快。
					vecter<int> vi(2，100);创建长度为2只装in数据的vecter，，默认值为100
						back()取出最后一个元素的值
						pop_back()删除最后一个元素   符合栈的功能
					vecter<int>::iterator it = v.end();相当于指向最后一个元素的指针
				    vecter本质是数组遍历可用下标和迭代器(指针)。
				list链表
				erase();删除指定元素
				list是链表遍历只能用迭代器(指针)。
				
				
			
			
			关联式容器：set,multiset,map,multimap
					set；创建对象时，不能指定长度。不能有重复的元素。插入的顺序与值的大小有关。
					multiset:相比set可也有重复值。
					map：键值对(导入<map>头文件)键值不能相同，只读取发现的第一个
					
			容器适配器：stack,queue,priority_queue
			
			
			  可以让函数名字相同