C语言，电路，模数电，大学物理，微机原理，单片机，信号与系统，
电力电子，过控，现控，自控，高数，概率论，线性代数，复变函数，
PLC，微型计算机控制，DSP，传感器理论，MATLAB，proteus

重点，联系，分类，熟练

处理器系统内容：
cpu内核（运行程序--ARM指令集，处理数据，处理中断异常--协处理器，权限管理），
IO接口
存储器--mmu，

数据手册：模块特性（feature）



ARM指令分类
分为六大类，数据处理指令，数据加载指令和存储指令，
分支指令，程序状态寄存器(PSR)处理指令，
协处理器指令和异常产生指令六大类。

格式：
操作码 条件码 s 目标寄存器 第一操作数(寄存器) 第二操作数（可以是立即数，寄存器和寄存器移位操作数）


条件码：是否影响CPSR寄存器的值，如果写了就影响，否则不影响
赋值就是与或非





ARM处理器的工作模式

ARM处理器的八种工作模式，我们把这八种工作模式以CPU的功能去划分：
1.正常运行
用户模式(user)： 正常执行程序，大部分任务处于这种模式下
系统模式(system)：运行特权级别任务程序
特权模式(SVC)：当复位或者软中断指令执行时进入这种模式，是一种保护模式。
2.中断
快速中断模式(FIQ):高优先级（FAST）中断产生时进入这种模式，用于高速						数据传输和通道处理。
外部中断模式(IRQ):一个普通中断产生时进入这种模式。一般中断处理。
3.异常
数据访问终止模式(ABT):当存储异常时进入这种模式。用于虚拟存储和存储						保护。
未定义指令终止模式(UND):当执行未定义的指令时进入这种模式。
4.Monitor （Cortex -A）
监控模式(MON): 运行安全软件，安全模式。


除了user模式其它模式都属于特权模式。
除了用户模式系统模式之外，都属于异常模式。




工作模式----寄存器-----流水线---中断、异常---指令集----伪代码




寄存器，由触发器构成。很重要的一个存储单元。对裸机程序的开发的其实就是对寄存器的设置。

单片机内部是在不同的模式配置寄存器，在外部是配置接口。


ARM指令在计算机中是32位的二进制数表示，所以占用4个字节。
最后，这些二进制码会被cpu通过固定的协议解析出来。

如ARM中有一条指令如下：
ADDEQS R0，R1，#85
其二进制码形式如下：
31~28	27~25	24~21	 20	19~16	15~12	11~0
0000	001	0100	1	0001	0000	0000 0000 1000
Cond		Opcode	 S	Rd	Rn	Operand2




条件码(31~28共4位表示，所以一共16个)：
条件域本质上是根据CPSR	寄存的条件状态位（N,Z,C,V）来判断


c变成伪代码，伪代码再变成汇编
（伪代码没有实际的处理器指令，但在编译时，会被替换成处理器相应的指令）

混合编程时：C语言中的变量和函数都会变为一个标签
汇编程序中接收 c语言的传参的是r0，r1
返回的结果小于32bit存到r0，小于64bit存到r0，r1


寻址方式都是在告诉我们如何寻找我们的操作对象

一个模块至少有两个寄存器：控制寄存器（控制模块的工作状态），数据寄存器（存储模块的工作数据）

mov 用于赋初值或是在寄存器间传送数据   

程序状态寄存器处理指令(MRS MSR):处理程序状态寄存器的读写指令
（不能用通用寄存器读写指令mov ）

mov mvn
lsl lsr asr ror
add adc sub rsb subs
mul muls mla umull umlal smull smlal
and orr eor bic
cmp cmn tst
b bl bx blx
mrs msr
ldr str ldrb ldrh ldrsh ldrsb dtrh drtb
ldm stm（ia,ib,da,db,fd,fa,ed,ea）
(主要用途有现场保护，数据复制，参数传递等)

验证sp指向的地址，mov r0,sp  sp--r13

我们在ARM汇编中如何规避立即数这个问题呢，
其实可以使用ARM汇编LDR伪指令，
例如直接把MOV指令变为，
 LDR R1，=0x12345678或
 LDR R1，=r2 -----将r2中的数据存到r1中
 类似----mov r1,r2
 这样编译器就不会报错了。
 但这种方法也有弊端会增加开销和影响执行效率。


混合编程：全局化---引用

delay：i=0，先加后判断（==m）<--->i=1,i<=m,i++--执行m次
变化加一，间隔不加
汇编实现条件语句：助记符后加s，
使语句可以改变cpsr中的值，
再加条件码，实现判断。
注意：cmp不需要显式的指定 S 后缀来更改状态标志。


宏函数：将一个地址值强转为指针，然后对它做读写操作

中断：中断源---GPIO---GIC----CPU核
（中断方式，开关，优先级，CPU选择）

ldr pc,label

label对应的指令码给pc,将异常模式的入口地址给PC

查用户手册：功能介绍，原理介绍，寄存器地址，寄存器中32位的功能
	/********************外设GPIO寄存器设置**************************/
	//1.设置GPX1PUD bit[3:2]为0，GPX1_1内部上拉下拉禁止
	REG_WRITE(GPX1PUD,REG_READ(GPX1PUD) & (~(0x3 << 2)));
	//2.将GPX1_1引脚设置为外部中断功能WAKEUP_INT1[1]	GPX1CON[7:4] = 0xf;
	REG_WRITE(GPX1CON,REG_READ(GPX1CON) & ~(0xf << 4) | (0xf << 4));
	//3.EXT_INT41_CON [6:4]设置为下降沿触发 0x2
	REG_WRITE(EXT_INT41_CON,REG_READ(EXT_INT41_CON) & ~(0x7 << 4) | (0x2 << 4));
	//4.EXT_INT41_MASK [1] 设置 使能中断
	REG_WRITE(EXT_INT41_MASK,REG_READ(EXT_INT41_MASK) & (~(0x1 << 1)));

	/************************GIC控制器寄存器设置************************************/
	//1.使能GIC
	REG_WRITE(ICDDCR,1);
	//2.使能相关的中断源转发给对应的CPU接口
	REG_WRITE(ICDISER1_CPU0,REG_READ(ICDISER1_CPU0) & (~(0x1 << 25)) | (1<<25));
	//3.选择CPU接口 CPU0
	REG_WRITE(ICDIPTR14_CPU0,REG_READ(ICDIPTR14_CPU0) & (~(0xff << 8)) | (1<<8));
	//4.使能所有中断信号到CPU0
	REG_WRITE(ICCICR_CPU0,1);
	//5.设置CPU0能接受中断优先级水平
	REG_WRITE(ICCPMR_CPU0,0xff);
	
	
一条指令的执行分为：取指，译码，执行三个主要阶段，
CPU由于使用流水线技术，造成当前执行指令的地址应该是PC C 8（32位机一条指令四个字节），
那么执行指令的下条指令应该是PC C 4。在异常发生时，CPU自动会将将PC C 4 的值保存到LR里，
但是该值是否正确还要看异常类型才能决定。


GPIO
1.上下拉禁止
2.变为中断功能
3.设置中断方式
4.开启中断
5.pending清除中断标志位


GIC（中断分配给CPU和CPU接口）
Distributor control register(ICDDCR):
将等待的中断源转发到处理器接口(使能GIC)

Interrupt set-enable register  (ICDISER)
使能相关的中断源转发给对应的CPU接口 

Processor targets register (ICDIPTR )
选择CPU接口 CPU0

CPU interface control register(ICCICR)
使能所有中断信号到CPU0

Interrupt priority mask register (ICCPMR)
设置CPU0能接受中断优先级水平





Interrupt Controller Type Register (ICDICTR)



中断向量表：
复位
未定义指令
软件中断swi
预取址中止
数据中止
一般中断
快速中断

当一种异常发生时，硬件就会自动执行如下动作:
(1)将CPSR保存到相应异常模式下的SPSR中
(2)将下一条指令的地址（被打断程序）（PC-4）
保存在LR(异常模式下LR_excep)中（PC可能更新，也可能没有更新）
		注：返回地址偏移量根据异常的类型而有所不同
如：		irq : 
				SUB    LR,LR,#4 ;计算返回地址  ，PC值更新了
				STMFD  SP!,{R0-R3,LR} ;保存使用到的寄存器
				干里你想干的事情
				.....
				LDMFD  SP!,{R0-R3,PC}^ ;中断返回

(3)将CPSR设置成相应的异常模式
(4)设置PC寄存器的值为相应处理程序的入口地址


UART（GPA1.1 GPA1.0）--可以封装成函数，传参就行了
1.设置IO(GPA1CON)
2.设置波特率(UBRDIV2，UFRACVAL2)
3.设置UART相关参数（ULCON2）---开始位，停止位，数据位，校验位
4.设置接收发送方式（UCON2）--设置为轮询模式
5.设置缓冲区（UFCON2）--关闭fifo
6.接收发送（UTXH2，URXH2,UTRSTAT2）--缓冲区需要判空判满
注意：初始时接收与发送缓冲区都为空
发送：
1.填充缓冲区（写）
2.等待发送完成
while(! (REG_READ(UTRSTAT2)&(1<<2)) );--不是1时就循环等待
while(a);--是1时就循环等待
接收：
1.等待接收完成
2.接收缓冲区（读）


watchdog timer：
WATCON,WATDAT,WATCNT 


led2一直闪烁，按下key2，进入中断，中断里发送串口数据
松开key2，led2一直闪烁
(写个头文件：定义地址和宏函数)


PWM:
蜂鸣器：GPD0.0
1.设置GPD0.0为pwm --TOUT_0

2.设置时钟（TCFG0--预分频器，TCFG1--位分频器）--pre = 199,div = 2


3.设置占空比和周期（TCNTB0，TCMPB0）--周期4ms，占空比90%

4.手动更新TCNT0，TCMP0（TCON）

5.停止手动更新TCNT0，TCMP0，设置
自动更新TCNT0，TCMP0           (TCON)
6.启动pwm定时器

G:\yagarto\bin\arm-none-eabi-gdb.exe
load
break _start
c




-----
A0
A1   UART/I2C
-----
B		 HS-SP1/I2C	
-----
USB OTG 2.0
HSIC
I2S / PCM / AC97 / SPDIF / I2C / SPI
------
K0
K1
------
K2
-----
K3


ADC：（采样，保持，量化，编码）---要清楚协议，原理等，不用了解外设内部结构
零度误差和满刻度误差，msps--千万次每秒
采样速率<=转换速率


初始化值（pin，mux--设置为功能模式，时钟，参数，启动（又是拆开来写））---初始化函数

1.设置预分频器--采样率，量化位数 等（ADCCON）
2.选择通道ADCMUX
3.开启转换---使能（ADCCON），读ADCDAT
4.读ADCDAT

将uart_printf当做printf用就行了

执行make all---bulid（开始时，默认指定第一个目标make）
1.链接libprintf.a，生成elf文件
2.生成libprintf.a的规则（make -C ./printf）
	1.切换目录./printf，执行make all
	2.在上一层生成libprintf.a

执行make clean---clean

clean：
rm -rf *.o *.elf *.a
make -C ./printf clean--指定目标
|
|
rm -rf *.o *.a



写：
1.计算好要写往寄存器的值（一次性）
2.读--修改（相应位清零然后或上数据）--写（多次）



I2c：4412---MPU6050
处理器和芯片间的通信可以形象的比喻成两个人讲话：1、你说的别人得能听懂：双方约定信号的协议。
2、你的语速别人得能接受：双方满足时序要求。

时钟高:开始位，停止位
时钟低：数据位改变
一个时钟周期内传输一个数据位：
时钟高时保持sda，时钟低时改变sda
如此在时钟高的时候就不会产生上升沿和下降沿（开始位，停止位）

应答：谁接收，谁应答--将sda线拉低，使他在一个时钟
脉冲内的高电平保持稳定的低电平

写流程：
连接（写）--写数据

读流程：
连接（写）--写寄存器的地址
连接（读）--读寄存器里的数据

我们按芯片手册的流程图走，芯片就会按照协议走
（不只是IIC，是通用的规则）

目标：通过I2C读陀螺仪里的x轴数据
1.IO口，中断置0，开I2C
2.流程图1142
3.使能





要点：控制寄存器，数据寄存器，状态寄存器，芯片特性
芯片原理图，工作流程图

1.gpio，key
2.uart
3.pwm
4.wdt
5.adc
6.i2c

1.gpio
控制，数据，上拉下拉

2.uart（协议）
IO功能，时钟（预分频器和位分频器）-波特率，开始位，数据位（5,6,7,8）
奇偶校验位，停止位（1,1.5,2），开关    ---发送数据
发送接收标志和缓冲区（poll，中断，DMA）--访问数据--4421中的模块是poll

3.pwm
IO功能，时钟，周期数，占空比（高电平数），重载备份，开关

4.wdt
时钟，触发方式（中断 or 复位），处理函数（异常向量表），
周期数，重载备份，开关

5.adc
时钟，转换频率，初始值，精度（量化位数）
转换通道（AIN3等），开关
转换标志和缓冲区（poll，中断，DMA）--4421中的模块是poll

6.i2c（协议）
IO功能，时钟，开始，停止，地址，数据，应答---发送数据
读写时序（数据格式），fifo与no fifo模式，
发送接收标志和缓冲区（poll，中断，DMA）---访问数据--4421中的模块是poll








