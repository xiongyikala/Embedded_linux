面向对象：
特性一：封装---数据抽象
隐藏对象的属性和实现细节仅对外公开接口，
控制在程序中属性的读取和修改的访问级别。
---get，put等

特性二：继承
多个类之间的关系，重写

特性三：多态
多态指同一个实体同时具有多种形式。
它是面向对象程序设计（OOP）的一个重要特征。
如果一个语言只支持类而不支持多态，
只能说明它是基于对象的，而不是面向对象的。
C++中的多态性具体体现在运行和编译两个方面。
运行时多态是动态多态，
其具体引用的对象在运行时才能确定。
编译时多态是静态多态，
在编译时就可以确定对象使用的形式。

多态性是允许你将父对象设置成为一个
或更多的他的子对象相等的技术，
赋值之后，父对象就可以根据当前赋值给它的子对象的
特性以不同的方式运作
多态性在Object Pascal和C++中都是通过虚函数实现的。
实现多态有以下方法：虚函数，抽象类，
覆盖，模板（重载和多态无关）



多态是基于对抽象方法的覆盖来实现的，用统一的对外接口来完成不同的功能。
重载也是用统一的对外接口
来完成不同的功能。那么两者有什么区别呢？
重载，是指允许存在多个同名方法，而这些方法的参数不同。
重载的实现是：编译器根据方法不同的参数表
，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。
它们的调用地址在编译期
就绑定了。
多态：是指子类重新定义父类的虚方法（virtual,abstract）。
当子类重新定义了父类的虚方法后，父类根据
赋给它的不同的子类，动态调用属于子类的该方法，这样的方法调用在编译期间是无法确定的。
不难看出，两者的区别在于编译器何时去寻找所要调用的具体方法，
对于重载而言，在方法调用之前，编译
器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
而对于多态，只有等到方法调用的那一刻
，编译器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 

一个有趣但不严谨的说法是：继承是子类使用父类的方法，而多态则是父类使用子类的方法。

1.环境搭建
测试编译工具gcc
安装虚拟机和集成开发环境eclispe---下载解压
运行环境jdk1.6.0_25--/etc/profile
注意权限
--export JAVA_HOME = /root/jdk1.6.0_25
export PATH = $JAVA_HOME/bin：SPATH
export CLASSPATH = .

3.用户名与密码
用户名1:root  密码1: wang198007
用户名2:wgr   密码2: wang198007

重新登录--设置生效
java命令测试
javac命令测试

C++与c的区别
1.在面向过程上做了扩充（头文件，库函数）--cin，cout等
2.增加了面向对象的机制


C++标准库定义了几种更高级的抽象数据类型，
包括string和vector类型。string类型提供了
变长的字符串，而vector类型则可用于管理同一
类型的对象集合。
迭代器实现了对存储于容器中对象的间接访问
迭代器可以用于访问和遍历string类型和vector
类型的元素




标准输入输出--iostream.h
include<iostream>
加入命令空间using namespace（关键字） std
cin，cout

编译：g++ test1.cpp -o test

endl是"\n"的宏定义
cout：无需指定输出的格式字符串
cout<<"data:"<<data<<endl
cin:输入时使用变量名接收，而不是使用地址接收
cin>>name

数据结构---标准库类型
字符串是怎样替换c语言的？
string1 = "mather"; ---strcpy
字符串赋值==
字符串连接+----strcat
字符串比较(关系运算符)---strcmp


引用：一种新的变量类型，它的作用是
1.为一个变量起一个别名---不会额外开辟空间
2.只作为函数的形参
3.比喻：引用是一种受限的指针(引用能做的指针都能做)
----引用的底层实现多数编译器也是指针
int a = 10;
int &b = a;//创建引用类型变量时，要立刻“赋值”
b = c;
逆向传参（int *p）
引用类型（int &r）

内联函数从源代码层看，有函数的结构，而在编译后，
却不具备函数的性质。内联函数不是在调用时发生控制转移，
而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，
使用函数体替换调用处的函数名。
一般在代码中用inline修饰，但是能否形成内联函数，
需要看编译器对该函数定义的具体处理。

类（设计图）和对象（房子）
类与类之间的关系：继承（包含）

类：属性和行为（是所有对象公有的）



方法1：定义声明写在一起---以免出现重复定义错误
1.新建cpp--添加#include "Stu.h"
2.新建stu.h--声明类

1.新建cpp--添加#include "Stu.h"
void f1(){
	//创建Stu类的对象
	Stu stu1; //变量age no name
	Stu stu2; //变量
	stu1.age = 10;
	stu1.no = 1;
	stu1.name = "小明";
}

void f2(){
	//创建Stu类的对象
	Stu stu1;
	Stu &stu2 = stu1; //对象也有引用类型
}
---内存分配
java所有对象都在堆区
C++中对象就是变量，在栈区分配内存
成员函数被对象共用，放在代码段中


2.新建stu.h--声明类
include<iostream>
using namespace（关键字） std;
class Stu{
public:
	//成员变量
	int age;
	int no;
	string name;
	//成员函数
	void sleep(){
		cout<<"sleep.."<<endl;
	}
	void study();

};

//域名访问符：指示此函数为Stu的成员函数
void Stu：：study(){
	cout<<"study.."<<endl;
}


方法2：定义声明分开
1.新建Stu.h----声明
2.新建Stu.cpp--定义


1.新建Stu.h
class Stu{
public:
	int age;
	void show1();
	void show2();

}

2.新建Stu.cpp
include<iostream>
using namespace（关键字） std;
void Stu：：show1(){
	cout<<"show1.."<<endl;
}
void Stu：：show2(){
	cout<<"show2.."<<endl;
}

函数重载：
--函数名一样，函数参数不一样
1.C风格的重载
2.类中成员函数的重载

1.C风格的重载
void fun(int x){
...
}
void fun(){
...
}
void fun(string x){
...
}

2.类中成员函数的重载
class Stu{
public:
	int age;
	void show();
	void show(int x);

}
多态指父类中定义的属性和行为被子类继承后，可以具有不同的数据类型或者表现行为。

默认参数值：
C函数
成员函数


构造函数：不写系统会自动为我们加上
创建对象时调用
--成员变量表

析构函数：不写系统会自动为我们加上
~Teacher()
对象被销毁时调用

关键字this是指针
--构造函数中的this指向当前正在创建的对象
--成员函数中的this指向当前正在调用该函数的对象

可以实现同一个类中函数与函数之间相互调用
成员函数可以通过this访问成员变量
--成员函数不能通过this访问构造函数



指向对象的指针 Stu *p

指向成员函数的指针
1.取地址
2.定义指针接收
3.调用
int Stu::show1(int x, int y) {
	cout<<"show1"<<endl;
	return 0;
int Stu::show2(int x, int y) {
	cout<<"show2"<<endl;
	return 0;
}
void Stu::show3() {
	cout<<"show3()"<<endl;
}

int(Stu::*p)(int,int) == &Stu::show
先要有对象
(Stu.*p)(1,2);

//	int Stu::show1(int x, int y)
//成员函数返回类型  (类名∷*指针变量名)(参数列表)=&类名∷成员函数名;
	int(Stu::*p)(int, int) = &Stu::show1; //p--->Stu::show1

	//(对象.*指针变量名)(实参);
	Stu stu;
	(stu.*p)(1,2);//show1
	
	
	p=&Stu::show2;//p--->show2;  show1的参数形式与show2相同
	(stu.*p)(1,2);//show2

	void(Stu::*p3)()=&Stu::show3;
	(stu.*p3)();//show3
	
	
	
常成员变量：只能通过构造函数的初始化表初始化
而普通变量可以使用this

常成员函数：不能修改对象
1.不能修改成员变量的值
2.只能调用成员函数
3.普通成员函数可以调用成员函数


常对象：不能修改对象
1.不能修改成员变量的值
2.只能调用成员函数
3.最好在定义常对象类的时候就用
构造函数把所有的成员变量初始化（常+普通）


动态创建对象--堆
new--delete
malloc--不会调用构造函数

对象的赋值与复制(克隆)
赋值：
创建---赋值
Stu stu1(300, 400);
	Stu stu2(3000, 4000);
	//对象赋值
	stu1 = stu2;//stu1.age = stu2.age; stu1.no=stu2.no;
	stu1.show();


复制(克隆)：--Stu stu3(stu1);
创建时克隆
---传参，返回
//对象复制
void f3(Stu  stu) {
//	cout<<&stu<<endl;
	stu.show();//age=1,no=2
}

Stu f4() {
	Stu stux(1, 2);
	return stux;
}

int main() {
	Stu stu1(1,2);
//	f3(stu1);
//	cout<<&stu1<<endl;

	Stu stu2 =  f4();//对象复制 stu2: age=1, no=2

	Stu stu3;
	stu3 = f4();//对象赋值stu3  age=1, no=2

	return 0;
}



复制构造函数
---涉及到内存泄漏

Stu::Stu(Stu &r){
	this->age = r.age;
	this->no = r.no;
}

栈里面的变量先进来后销毁



静态成员变量：
对象产生之前就产生了，对象产生后可以
使用它，对象销毁后，它也不会销毁
---相当于对象之间的共享内存
访问方式：
对象.a;
类::a

静态成员函数中不能出现this，
因为它不属于某一个具体的对象，它属于类
//不能通过this访问其他成员函数


访问权限修饰符
public--公共
protected--同类，子类
private--同类


--java中除private外同类可访问必定同包可访问
默认--子类不可访问

1、修饰成员变量（成员变量，成员方法，构造函数，析构函数）
--改变成员的作用域，不改变内存分配
2、修饰继承方式
--被继承类的成员和构造函数在子类的作用域

函数比变量安全-->隐藏私有数据


友员:
打破访问权限的限制，共享数据
友员的C函数，成员函数，类

表象：语法，类，结构体，链表等
根源性内因：逻辑关系

继承与派生（子类）：--解决代码的重用
多重继承（多个基类）


类型上的继承关系
--使用单继，使用多级继承（传递性）

class B:public A，public C
{
	//B类公有继承A，C
}

class B:A
{
	//B类私有继承A
}


使用访问权限限制继承
1.基类中private修饰的成员始终不能被派生类继承
2.基类中public修饰的成员与protected修饰的成员
始终可以被派生类继承

private属性不可继承
--继承后相当于在派生类中声明了继承的成员
--注意访问权限的传递规则（基类中成员的属性，继承下来后成员的属性）
public继承---原样继承
protected继承---protected
private继承---private


派生类的构造函数和析构函数：
派生类的构造函数调用基类构造函数
1.写--使用初始化成员表
B::B():A(23),x(123){//B类中有一个成员为x

}
B::B(int y):A(y),x(123){

}
2.默认不写时，调用不用传参的构造函数
B::B(int y):A(),x(123){

}
<======>
B::B(int y),x(123){

}

--多基继承可能会产生二异性
b.A1::a = 2;
b.A1::m();
b.A2::a = 2;
b.A2::m();

共同基类产生的二异性（多级继承+多个基类）
解决方法：虚基继承，虚基派生---只继承一份相同的A成员
class B1:virtual public A{..}
class B2:virtual public A{..}
class A: public B1,B2{..}
多级继承（传递性）

赋值：同类，派生类-->基类
派生类对象向基类对象赋值


核心：
1.类 对象
2.继承
3.组合
4.虚函数
5.抽象类--隐藏


基类声明的指针变量和引用变量
指向派生类的对象
派生类对象与它包含的“基类对象”首地址相同
指针访问的对象与指针的类型相关


组合：将对象作为成员变量
初始化成员表--指定组合的成员函数
---类似java里的接口，添加功能
按java的思想是实现接口，接口是实现的父类

--便于扩展，便于维护
--符合面向对象思想

内存的处理上
java的内存的处理不用用户来管理，内存自动回收

C++和C一样内存的操作是最难的部分，容易出现内存泄漏

java可以跨平台
C++在Qt平台也可以跨平台

设计原则--设计模式：23种


基类+组合
基类的构造函数最先执行

管理资源--电脑，人等

思考：
单基继承---类型继承
继承与组合--类型上的包含关系，同类继承
组合--整体与部分的关系，此部分不是整体必须的
只是功能的扩展


多态：--使用回调实现的


隐藏：派生类与基类成员名相同时，
派生类成员就会隐藏基类成员
函数原型相同--特殊的隐藏：重写


override
overload


虚函数：
对象指针访问普通函数时，只看指针的类型-base
对象指针访问虚函数时，只看指针的值--child

---可以实现回调
---后写的代码A指向会触发先写的代码
调用后写的代码B

后写的代码：
1.触发代码
2.回调函数代码

开线程：
1.触发代码：phread_create(,函数指针)
2.回调代码：线程执行函数


多态：指针访问虚函数
重载，重写，this

动态关联，动态编联，
静态关联

虚析构函数：解决内存泄漏
--基类指针指向动态创建的派生类对象
virtual ~A();--不加的话，只会调用基类的析构函数，不会调用
派生类的
基类的虚析构函数会传递给派生类




纯虚函数--抽象方法
virtual 函数类型 函数名（参数列表） = 0；
抽象类：包含纯虚函数的类
可以用抽象类创建的指针和引用
类指向抽象类的派生类对象

抽象类的派生类没有把抽象类的纯虚函数
实现完，那么这个类也是抽象类
纯虚函数被派生类实现以后即为虚函数



重写：为了解决代码的重用
实际开发中，都是重写虚函数
使用虚函数就是有重写的需求

重写是对继承下来的函数体不满意



构造函数的访问权限修饰符
派生类的构造函数可以触发
被public和protected修饰基类的构造函数

派生类的普通函数不可以触发
被protected修饰基类的构造函数

私有构造函数的解决方法
---类似java的单例模式
Teacher t = Teacher::getTeacher();
//Teacher t( Teacher::getTeacher() );


名称空间：namespace
--解决命名重复
namespace std{}
namespace fs{
	namespace fs{}
	void show();
}

泛型/模板
STL容器--使用模板封装了很多类
----什么时候使用容器
---用于传递复杂的数据
容器 = 数据结构 + 算法
C写算法，用算法
C++用算法


运算符重载



泛型/模板
C风格的函数模板
template<class T1>
template<typename T1>


C++风格的函数模板
template<class T1>
class 类名{

}
多态:一个实体具有多种表现形式。
C++的天下是游戏


STL容器：
--类：封装了数据结构和算法
--添加元素是需要使用泛型
包括大部分数据结构
分三类：
1.顺序性容器---3
查询和插入
vector
deque
list

vector：一个个创建数组1.2.3.。
---数据追加就是数组追加
就是新创建数组，
并销毁原来的数组
---添加元素比较慢，查询快


vector<class> 对象;

(&ia[2],&ia[5])--左闭右开
克隆
vector<class> v2(v1);

v1.push_back--最后添加
v1.back--取出最后一个元素的值
vi.pop_back--删除最后

迭代器--指针
vector<int>::iterator it = v.begin();
遍历：下标，迭代器


list：查询慢，其他快
l.push_front--前面添加
l.erase(it);
l.remove(20);
l.clear();
遍历：迭代器
---里面是链表


2.关联式容器--4
set：
--元素没有重复
--天生有顺序
遍历：迭代器
---里面是树

multiset：
--元素可以有重复

map：天生根据主键来排序
存一对（键+值）
属性文件就是由键值对组成
--元素没有重复--根据键
内部类--value_type(3,"three");


multimap：天生根据主键来排序
--元素可以有重复
存一对（键+值）


3.容器适配器--3
stack
queue
priority_queue



运算符重载：
C风格函数+运算符(=-..)，
成员函数+运算符(=-..)
--重载为运算符(=-..)
复数：
函数名operator+
重载后为+

最好将被重载的函数声明成友元













